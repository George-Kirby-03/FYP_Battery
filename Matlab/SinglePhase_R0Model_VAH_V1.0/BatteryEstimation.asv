function [problem,guess,phaseoptions] = BatteryEstimation
%BangBang - BangBang Control (Double Integrator Minimum Time Repositioning) Problem with a multi-phase formulation
%
% The problem was adapted from Example 4.11 from
% J. Betts, "Practical Methods for Optimal Control and Estimation Using Nonlinear Programming: Second Edition," Advances in Design and Control, Society for Industrial and Applied Mathematics, 2010.
%
% Outputs:
%    problem - Structure with information on the optimal control problem
%    guess   - Guess for state, control and multipliers.
%
% Other m-files required: none
% MAT-files required: none
%
% Copyright (C) 2019 Yuanbo Nie, Omar Faqir, and Eric Kerrigan. All Rights Reserved.
% The contribution of Paola Falugi, Eric Kerrigan and Eugene van Wyk for the work on ICLOCS Version 1 (2010) is kindly acknowledged.
% This code is published under the MIT License.
% Department of Aeronautics and Department of Electrical and Electronic Engineering,
% Imperial College London London  England, UK 
% ICLOCS (Imperial College London Optimal Control) Version 2.5 
% 1 Aug 2019
% iclocs@imperial.ac.uk

load("Data\VAH_Seg1_charging.mat")
tf_1=tt(end);
load("Data\VAH_Seg2_TO.mat")
tf_2=tt(end);
load("Data\VAH_Seg3_CRZ.mat")
tf_3=tt(end);
load("Data\VAH_Seg4_LAND.mat")
tf_4=tt(end);
load("Data\VAH_Seg5_rest.mat")
tf_5=tt(end);
% Initial and final time for different phases. Let t_min(end)=t_max(end) if tf is fixed.
problem.mp.time.t_min=[0 tf_1 tf_2 tf_3 tf_4 tf_5];     
problem.mp.time.t_max=[0 tf_1 tf_2 tf_3 tf_4 tf_5]; 
guess.mp.time=[0 tf_1 tf_2 tf_3 tf_4 tf_5];

% Parameters bounds. pl=< p <=pu
problem.mp.parameters.pl=[2.5 -10 -50 20 -200 20 -40  0.001 -10 -10  -10             2.5*3600  6000  0 1000]; % p7 Q C1 R0 R1 Cp -100 -200 -100 -100
problem.mp.parameters.pu=[4 10 -10 120 -20 120 0      0.1  10 10 10               3.5*3600 10000  0.01 4000]; %300 300 100 100
guess.mp.parameters=[2.5 7.6 -26 50 -43 14  0         0.005 0 0 0              3*3600 8000 0.003  2025.737]; %0 0 0 0
problem.mp.data.OCV_Np=7;
problem.mp.data.R0_SOC_Np=3;
problem.mp.data.R0_i_Np=1;

problem.mp.data.Np_poly=problem.mp.data.OCV_Np+problem.mp.data.R0_SOC_Np+problem.mp.data.R0_i_Np;

syms SOC current
syms p [1 problem.mp.data.OCV_Np+problem.mp.data.R0_SOC_Np+problem.mp.data.R0_i_Np] 
OCVModel=p(:,1);
for i=2:problem.mp.data.OCV_Np
    OCVModel=OCVModel+p(:,i).*SOC.^(i-1);
end
matlabFunction(OCVModel,"File","OCVModel","Vars",{p,SOC});

OCVModel_dSOC=p(:,2);
for i=3:problem.mp.data.OCV_Np
    OCVModel_dSOC=OCVModel_dSOC+(i-1)*p(:,i).*SOC.^(i-2);
end
matlabFunction(OCVModel_dSOC,"File","OCVModel_dSOC","Vars",{p,SOC});

R0Model=p(:,problem.mp.data.OCV_Np+1);
for i=2:problem.mp.data.R0_SOC_Np
    R0Model=R0Model+p(:,problem.mp.data.OCV_Np+i).*SOC.^(i-1);
end
for i=1:problem.mp.data.R0_i_Np
    R0Model=R0Model+p(:,problem.mp.data.OCV_Np+problem.mp.data.R0_SOC_Np+i).*current.^(i);
end
matlabFunction(R0Model,"File","R0Model","Vars",{p,SOC,current});

% Bounds for linkage boundary constraints bll =< bclink(x0,xf,u0,uf,p,t0,tf,vdat) =< blu
problem.mp.constraints.bll.linear=[zeros(1,3*5)];
problem.mp.constraints.blu.linear=[zeros(1,3*1)];
problem.mp.constraints.blTol.linear=[0.01*ones(1,3*1)];

problem.mp.constraints.bll.nonlinear=[];
problem.mp.constraints.blu.nonlinear=[];
problem.mp.constraints.blTol.nonlinear=[];

% Get function handles
problem.mp.linkfunctions=@bclink;

% Store the necessary problem parameters used in the functions



% problem.mp.data.Q=15*60*60;
% problem.mp.data.R0=0.003;
% problem.mp.data.R1=0.002;
% problem.mp.data.C1=8000;
% problem.mp.data.batt_m=39e-03;
% problem.mp.data.batt_Cp=2025.737;
% problem.mp.data.batt_h=43.061;
% problem.mp.data.batt_A=3.714e-03;
% problem.mp.data.TempAmb=15;

% problem.mp.data.Q=2.0*60*60; %15*60*60l %10800
% problem.mp.data.R0=0.0012;%0.0163;  %0.0225;
% problem.mp.data.R1=0.003; %0.0221; %0.03;
% problem.mp.data.C1=8000;  %8000; %1000;
problem.mp.data.batt_m=46.8e-03;         %39e-03;
% problem.mp.data.batt_Cp=2025.737; 
problem.mp.data.batt_h=43.061;
problem.mp.data.batt_A=1.206e-03;        %3.714e-03;
problem.mp.data.TempAmb=23;

% Define different phases of OCP
[problem.phases{1},guess.phases{1}] = BatteryEstimation_Phase1_Charging(problem.mp, guess.mp);
[problem.phases{2},guess.phases{2}] = BatteryEstimation_Phase2_TO(problem.mp, guess.mp);
[problem.phases{3},guess.phases{3}] = BatteryEstimation_Phase3_CRZ(problem.mp, guess.mp);
[problem.phases{4},guess.phases{4}] = BatteryEstimation_Phase4_LAND(problem.mp, guess.mp);
[problem.phases{5},guess.phases{5}] = BatteryEstimation_Phase5_rest(problem.mp, guess.mp);

phaseoptions{1}=problem.phases{1}.settings(20);
phaseoptions{2}=problem.phases{2}.settings(50);
phaseoptions{3}=problem.phases{3}.settings(20);
phaseoptions{4}=problem.phases{4}.settings(50);
phaseoptions{5}=problem.phases{5}.settings(20);

%------------- END OF CODE --------------


function [blc_linear, blc_nonlinear]=bclink(x0,xf,u0,uf,p,t0,tf,vdat)

% bclink - Returns the evaluation of the linkage boundary constraints: bll =< bclink(x0,xf,u0,uf,p,t0,tf,vdat) =< blu
%
% Syntax:  [blc_linear, blc_nonlinear]=bclink(x0,xf,u0,uf,p,t0,tf,vdat)
%
% Inputs:
%    x0  - state at t=0
%    xf  - state at t=tf
%    u0  - input at t=0
%    uf  - input at t=tf
%    p   - parameter
%    tf  - final time
%    vdat- structured variable containing the values of additional data used inside
%          the function
%
%          
% Output:
%    blc_linear - column vector containing the evaluation of the linear linkage boundary constraint functions
%    blc_nonlinear - column vector containing the evaluation of the nonlinear linkage boundary constraint functions
%
%------------- BEGIN CODE --------------

blc_linear=[xf{1}(1:3)-x0{2}(1:3);xf{2}(1:3)-x0{3}(1:3);xf{3}(1:3)-x0{4}(1:3);xf{4}(1:3)-x0{5}(1:3)];
blc_nonlinear=[];
%------------- END OF CODE --------------
